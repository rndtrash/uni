# Вставка и удаление элементов

```cpp
/*       __________________
 *       |                 V
 * P           P->NEXT     R->NEXT
 * |--|--|     |\-|-/|     |--|--|
 * |  |  | --> | \|/ | --> |  |  |
 * |__|__|     |__X__|     |__|__|
 *               / \
 *              /   \
 */

if (p->next->info == свойство)
{
	r = p->next; // поставить r на удаляемый элемент
	p->next = r->next; // исключить r из списка
	delete[] r; // удалить элемент из списка
}
```

```cpp
list *r; // вспомогательная переменная для удаления
p = beg;
while (p->next != NULL)
{
	if (p->next->info == свойство)
	{ // удалить элемент
		r = p->next; // поставить r на удаляемый элемент
		p->next = r->next; // исключить r из списка
		delete[] r; // удалить элемент из списка
	}
	else
		p = p->next; // переход к следующему элементу списка
}

//обработка частного случая - первого элемента
if (beg->info == свойство)
{
	p = beg;
	beg = beg->next;
	delete[] p;
}
```

__***Пример 5***__. Удалить все положительные элементы, за которыми следует элемент с равными последней и предпоследней цифрой.

```cpp
p = beg;
while (p->next->next != NULL)
{
	if (p->next->info > 0
		&& p->next->next->info % 10 == p->next->next->info / 10 % 10)
	{
		p->next = p->next->next;
	}
	else
		p = p->next;
}

// обработка частного случая - первого элемента
if (beg->info > 0 && beg->next->info % 10 == beg->next->info / 10 % 10)
	beg = beg->next;
```

__***Пример 6***__. Удалить простые элементы, до которых идёт непростой элемент, с последней цифрой 2.

```cpp
int Pr(int x)
{
	for (int i = 2; i < x; i++)
		if (x % i == 0)
			return 0;
	return 1;
}
/// --- ///
p = beg;
while (p->next != NULL)
{
	if (Pr(p->next->info) && !Pr(p->info) && p->info % 10 == 2)
		p->next = p->next->next;
	else
		p = p->next;
}
```

__***Пример 7***__. УДалить все элементы с чётной суммой цифр, расположенные между равными элементами.

```cpp
int Sum(int x)
{
	int s = 0;
	while (x)
	{
		s += x % 10;
		x /= 10;
	}
	return s;
}
/// --- ///
p = beg;
while (p->next->next != NULL)
{
	if (Sum(p->next->info) % 2 == 0 && p->info == p->next->next->info)
		p->next = p->next->next;
	else
		p = p->next;
}
```

# Вставка элемента ПОСЛЕ заданного

```cpp
/*    P                        P->next
 * |--|--|           /         |--|--|
 * |  |  | ---------/--------> |  |  |
 * |__|__| \       /        /  |__|__|
 *          \              /
 *           \   |--|--|  /
 *            -->|  |  |--
 *               |__|__|
 *                  R
 */

list *p = beg;
list *r;
while (p != NULL)
{
	if (p->info == свойство)
	{
		r = new(list);
		r->info = новый элемент;
		if (p->next != NULL)
			// если p не последний
			r->next = p->next;
		else
			r->next = NULL; // это не обязательно!
		p->next = r;
		p = p->next; // обход нового элемента
	}
	p = p->next; // переход к следующему элементу списка
}
```

__***Пример 8***__. Вставить новый элемент со значением z ПОСЛЕ элемента каждого нечётного элемента

```cpp
list *p = beg;
list *r;
while (p != NULL) // пока нет конца списка
{
	if (p->info % 2 != 0)
	{
		r = new(list);
		r->info = z;
		r->next = p->next;
		p->next = r;
		p = p->next;
	}
	p = p->next; // переход к следующему элементу списка
}
```

# Вставка ДО заданного элемента

```cpp
list *p = beg;
list *r;
while (p->next != NULL) // пока нет конца списка
{
	if (p->next->info == свойство)
	{
		r = new(list);
		r->info = новый элемент;
		r->next = p->next;
		p->next = r;
		p = p->next; // обход нового элемента
	}
	p = p->next; // переход к следующему элементу списка
}
```

__***Пример 9***__. Вставить новый элеметн со значением наибольшего элемента списка ДО каждого отрицательного элемента.

```cpp
list *p = beg;
max = p->info;
while (p != NULL)
{
	if (p->info->max)
		max = p->info;
	p = p->next;
}
list *r;
p = beg;
while (p->next != NULL)
{
	if (p->next->info < 0)
	{
		r = new(list);
		r->info = max;
		r->next = p->next;
		p->next = r;
		p = p->next;
	}
	p = p->next; // переход к следующему элементу списка
}
```

__***Пример 10.***__. Вставить новый элемент со значением наибольшего элемента списка ДО каждого отрицательного элемента

```cpp
/*          beg
 *          |--|--|        |--|--|
 *          |  |  | -----> |  |  | -----> . . .
 *          |__|__|        |__|__|
 *          ^
 *-R-  beg /
 * |--|--|/
 * |  |  |
 * |__|__|
 */

// частный случай - вставка до первого элемента
if (beg->info < 0)
{
	r = new(list);
	r->info = max;
	r->next = beg;
	beg = r;
}
```
