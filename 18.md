# Алгоритм Крускала

Пусть G={V,E} связный граф со множеством вершин V={1, 2, ..., n} и функцией стоимостей c, определённой на множестве рёбер E.

Построение оставного дерева минимального стоимости для графа G начинается с графа T={V, ~~0~~}, состоящего только из n вершин графа G и не имеющего рёбер. Таким образом каждая вершина является связной
компонентой (сама с собой). В процессе выполнения алгоритма имеется набор связных компонент, постепенно объединяя которые формируется оставное дерево.

```cpp
#define SIZE 6
int a[SIZE + 1][SIZE + 1]; // матрица связей
int w1, w2;
void min() // поиск ребра наименьшей стоимости
{
	int m = 1000;
	for (int i = 1; i <= SIZE; i++)
	{
		for (int j = 1; j <= SIZE; j++)
		{
			if (m < a[i][j])
			{
				m = a[i][j];
				w1 = i;
				w2 = j;
			}
		}
	}
	if (m != 1000)
	{
		a[w1][w2] = 1000; // убрать ребро из дальнейшего просмотра
	}
	else
	{
		w1 = -1; // маркер -- рёбер больше нет
	}
}

int main()
{
	int t[2][SIZE + 1]; // массив рёбер оставного дерева
	int v[SIZE + 1]; // компоненты связности
	int index = 0;
	// ...ввод матрицы связей, если нет ребра a[i][j] = 1000
	// инициализация непосещённых вершин
	for (int i = 1; i <= SIZE; i++)
	{
		v[i] = i; // каждая вершина принадлежит своей компоненте
	}
	// шаг алгоритма
	do
	{
		min(); // (w1, w2) ребро наименьшей стоимости
		if (v[w1] != v[w2])
		{
			t[0][index] = w1;
			t[1][index] = w2;
			index++; // берём ребро в дерево
			int temp = v[w2];
			for (int i = 1; i <= SIZE; i++) // и присваиваем им номер
			{
				if (v[i] == temp) // одной компоненты, все вершины из компоненты w2
				{
					v[i] = v[w1];
				}
			}
		}
		else
		{
			a[w1][w2] = 1000;
		}
	} while (w1 > -1);

	// Вывод рёбер оставного дерева
	std::cout << "Рёбра оставного дерева: " << std::endl;
	for (int i = 0; i < index; i++)
	{
		std::cout << "( " << t[0][i] << " ; " << t[1][i] << " )" << endl;
	}
}
```

# Введение в компиляторы

Компилятор состоит из двух основных блоков (процессов): анализ программы и синтез машинного эквивалента.

На этапе анализа проверяется семантическая и синтаксическая корректность, выявляется её структура, определяются её отдельные элементы, лексемы, описания, разделители, операторы, и формируется промежуточная
форма представления программы.

На этапе синтеза выполняются подготовительные действия к генерации кода и собственно генерация.

## Информационные таблицы

На вход компилятору поступает исходная программа в виде текстового файла. Все элементы, которые будут распознаны компилятором, либо находятся в информационной таблице, либо будут помещены туда.

Существуют информационные таблицы в виде индефикатора (делятся на таблицы ключевых слов и таблицы имён), констант, циклов и блоков. Элемент информационной таблицы имеет структуру: аргумент и значение в поле
аргумент например в таблице идентификаторов заносится собственный идентификатор, а в поле значения может указываться его тип кол-во занимаемых байт признак локальности, глобальности и т.д.

На первом этапе компилятора работает сканер,ему на вход поступает последовательность литер. Сканер преобразует последовательность литер в поледовательность лексем,используя таблицу разделителей. На следующем
этапе работает синтаксический анализатор, сначала с помощью таблиц ключевых слов выделяются относящихся к ним лексемы далее они объединяются в более крупные конструкции.

Синтаксический анализатор определяет корректность таких конструкций, помещённых в информационную таблицу, как констант. При необходимости синтаксический анализатор формирует ошибку периода компиляции.
