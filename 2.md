# Шаблоны функций

Это средство языка, предназначенные для кодирования обобщённых алгоритмов без привязки к конкретным параметрам (например, типам данных).

```cpp
template <typename T>
void change(T &a, T &b)
{
	T temp;
	temp = a;
	a = b;
	b = temp;
}

...

int a = 5, b = 7;
change(a, b);
double f = 1.5, d = 3.7;
change<double>(f, d);
```

Компилятор автоматически преобразует шаблон `T` к типу `int`.

# Указатели

Рассмотрим описание переменной `int i = 10;`. В этом случае выделяется память в 4 байта, значение 10 размещается в младшем байте. Можно напрямую
обратиться к адресу выделенного блока памяти.

Адреса ячеек можно хранить в указателях. Различают указатель:
 * на объект;
 * на функцию;
 * на `void`

**Указатель на функцию** содержит адрес сегмента кода, по которому располагается исполняемый код функции.

```cpp
тип (*имя)(список аргументов);
```

Пример:

```cpp
int (*fun)(int, double);
```

**Указатель на `void`** применяется в тех случаях, когда конкретный тип объекта, адрес которого необходимо получить, неизвестен. Указатель на
`void` можно сравнивать, а также присваивать ему адрес любого типа.

**Указатель на объект** содержит адрес области памяти, в которой хранятся данные определённого типа.

Синтаксис:

```cpp
тип *имя;
```

Пример:

```cpp
int *a, *b;
// Также можно так:
int* a;
// И даже так:
int * a;
```

Существует специальная операция взятия адреса `&`. Её результатом также является адрес объекта.

Пример:

```cpp
int i; // переменная

const int ci = 1; // константа

int *pi; // указатель на переменную

const int *pci; // указатель на константу

int *const cp = &i; // неизменяемый указатель на переменную

const int *const cpc = &ci; // неизменяемый указатель на константу
```

Если модификатор `const` относится к указателю (находится между именем указателя и звёздочкой), то он запрещает изменение указателя.
Если же он находится слева от звёздочки, запрещается изменение значения переменной.

Для инициализации указателя существуют следующие способы:

 1. С помощью операции получения адреса:

```cpp
int a = 5;
int *p = &a; // int p(&a);
```

 2. С помощью проинициализированного указателя:

```cpp
int *r = p;
```

 3. Адрес присваивается в явном виде:

```cpp
char *cp = (char*)0xB8000000;
```

 4. Присваивание пустого значения:

```cpp
int *N = NULL;
```

## Динамические переменные

Динамическая память - это память, выделенная программе для размещения локальных переменных и собственно тела функций. Для работы с динамической
памятью используют указатели. С помощью указателей осуществляется доступ к участкам динамической памяти, которые называются динамическими
переменными.

В языке C++ существуют два способа работы с динамической памятью:

 1. Работа с функциями семейства `malloc`

 2. Для выделения памяти под переменные используется метод `new`, а для освобождения выделенной памяти используется метод `delete`

    Синтаксис `new`:

```cpp
указатель = new имя_типа(иниц);
```

    Пример:

```cpp
int * x = new int(5); // будет выделено 4 байта и записано значение 5
```

    Синтаксис `delete`:

```cpp
delete указатель;
```

    Пример:

```cpp
delete x;
```

## Операции с указателями

С указателями можно выполнять следующие операции:

 1. Разыменование (получение адреса):

```cpp
int a;
int *pa = new int;
*pa = 10;
a = *pa;
```

 2. Присваивание:

```cpp
int *pb = pa;
```

 3. Сравнение указателей:

```cpp
if (pa < pb)
{
}
```

    Такая операция не имеет смысла. Есть смысл только в использовании `==` и `!=`.

 4. Арифметические операции:

```cpp
char *pc;
int *pi;
float *pf;

pc++; // +1 прибавляется к самому указателю, а не переменной
pi++; // +4
pf++; // +4
// т.е. увеличивает на sizeof(типа)
```

    Аримфетические операции применяются только к указателям одного типа. Допустимы: инкремент, декремент, разность двух указателей, сложение
указателя и константы

 5. Приведение типов: на одну и ту же область памяти могут ссылаться указатели разного типа. При операции разыменования `&` можно получить разные
результаты.

```cpp
int a = 123;
int *pi = &a;
char *pc = (char*) &a;
float *pf = (float*) &a;
cout << pi << *pi << endl;
cout << pc << *pc << endl;
cout << pf << *pf << endl;
```
