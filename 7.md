решётка заголовок
блок кода - три ```cpp, затем ``` без cpp

#Кольцевые списки

``` beg =new(list); 
list *r,*p;
int x;
cin >> x;
beg->inf = x;
p=beg;
while(x!= marker){
r=new(list);//сформировать следующиий элемент
r->info=x;
r->next=MULL;
r->next=r;
r->pred=p;
p=r;
}
}
ВАЖНО beg->pred=p;p->next=beg;
```
#Cхема обработки кольцевого списка
```
p=beg;
do {
обработка (p->info)
p=p->next; переход к следующему элементу списка
}
while (p!=beg);
```
#Рекурсивная обработка списков
```void F(list *p)
{
 if (p!= NULL) / пока нет конца списка
  { 
   obrabotka 
   F(p->next);
  }
{
```
# Заменить все отр элементы значением их квадрата
``` void Zam(list*p)
{
	if (p != NULL)
		{
		 if (p->info<0) p->info*=p->info;
		 Zam(p->next);
		}
}

```
# Целочисленная рекурсивная функция

``` 
int F(list)
{
	if (p!=NULL)
	{ if (p->info == свойство) k=1(p->info)
	  else k=0;
	  return k+F(p->next); // переход к следующему элементу
	}
else return 0;
}
Каждому ифу надо елсе
```
# пример найти сумму чётных элементов списка
```
int sum(list*p)
{
int s;
if (p!=NULL)
	{
	if (p->info%2==0) s=p->info;
	else s=0;
	return (s+sum(p->next);
	}
else return 0;
}
```
# Найти кол-во делящихся на 5 элементов списка 
```
int kolvo(list*p)
{
	int k;
	if (p!= NULL)
	{
		if (p->info%5==0) k=1;
		else k=0;
		return k+kolvo(p->next);
	}
	else return 0;
}
```
При двух задачах сделать 2 функции 
```
void Zam(list*p)
{
        if (p != NULL)
                {
                 if (p->info<0) p->info=s;
                 Zam(p->next);
                }
}
... s=sum(beg); Zam(beg,s);
```
# Двоичные деревья
Деревья. Основные понятия
Корневым двоичным деревом будем называть либо пустое множество, либо непустое множество в котором определён один элемент t называемый корнем
дерева, а все остальные элементы разбиты на 2 непересекающихся подмножества tl,tr являющиюся в свою очередь корневыми двоичными деревьями
Узлы дерева,являющиеся корнями левами и правами поддеревьев будем называть сыновьями. Узлы дерева,не имеющие сыновей называются листъями
Узел r будем называть потомком узла k,если либо n является сыном узла k либо существует такой узел l,для которого n является сыном и l является
потомком узла k(рекурсивное определение)
Сыновья одного и того же узла называются братьями.
``` struct tree
{
	int info; // inf pole
	tree *L;
	tree *r;
};
```
# Дерево двоичного поиска (ДДП)
Будем предпологать что информационная состовляющая узлов дерева принадлежит типу на котором определено отношение линейного порядка(из одного 
следует другого но не наоборот)ДДП будем называть корневое двоичное дерево у которого все информационные составляющие левого поддерева
меньше информационной составляющей корня,а все информационные составляющие правого поддерева больше информационной составляющей корня причём 
левое и правое поддеревья являются ДДП.
```
void add (tree*t,int x)
tree *q 
if (x<t->info)
	if (t->L==NULL)
	{ q =new (tree); q->info = x;
	q->L=NULL;q->R=NULL;t->L=q;
	else add(t->L,x);
else
	(if t->r==NULL) {
		q=new(tree);
		q->info=x;
		q->L=NULL;
		q->R=NULLl
		t->R=q;}
	else add (t->R,x);
}
void main()
{
	int x;
	tree*beg=new(tree);
cin>>x;
beg->info=x;
beg->L=NULL;
beg->R=NULL;
while(x!=0){
	cin >>x;
	if (x!=0) add(beg,x)
} 
Функция добавляет 1 элемент дерева а не всё дерево целиком 
