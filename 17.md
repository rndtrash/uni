# чо то там про сильную связность

# Алгоритм нахождение сильно связанных компонент

 1. Выполнить поиск вглубину на графе G. Вершины пронумеровать в порядке завершения рекурсивно вызванной процедуры dfs.

```cpp
for (v = 1; v <= n; v++)
	mark[v] = unvisited;

for (v = 1; v <= n; v++)
	if (mark[v] == unvisited)
		dfs(v);

// поиск вглубину

void dfs (вершина v)
{
	вершина w;
	{
		mark [v] = visited;
		for каждая вершина w из списка L[v]
			if (mark[w] == unvisited)
				dfs(w); {строка *}
	}
}
```

 2. Создать новый ор. граф Gr путём обращения направления всех дуг графа G.
 3. Выполнить поиск в глубину на графе G, начиная с вершины с наибольшим номером, полученном на шаге 1. Если проведённый поиск не охватывает всех вершин, то начать новый поиск с вершины, имеющей наибольший номер
    среди оставшихся.

# Представление ориентированных графов

# Оставные деревья минимальной стоимости

Пусть G = {V, E} -- связный граф, в котором каждое ребро {v, w} помечено числом c{v, w}, которое называется **стоимостью ребра**. Остовным деревом графа G называется свободное дерево, содержащее все вершины V
графа G. *Стоимость* остовного дерева вычисляется как сумма стоимостей всех рёбе, входящих в это дерево.

# Свойство ОДМС

Пусть G = {V, E} -- связный граф с заданной функцией стоимости, определённой на множестве рёбер. Обозначим через U подмножество множества вершин V.

Если {u, v} -- такое ребро наименьшей стоимости, что u принадлежит U и v принадлежит V\U, тогда для графа G существует оставное дерево бла бла бла

# Алгоритм Прима

мн елень

```cpp
#define SIZE 6

int main()
{
	int a[SIZE + 1][SIZE + 1];
	int t[2][SIZE + 1];
	int v[SIZE + 1];
	int w1, w2, index = 0, min;
	// вот матрицы связей, если нет ребра
	a[i][j] = 1000;
	// Инициализация непосещённых вершин
	for (int i = 2; i <= SIZE; i++)
		v[i] = 1;
	v[1] = 0; // вершину посетили
	// шаг алгоритма
	do {
		min = 1000;
		for (int i = 1; i <= SIZE; i++)
			for (int j = 1; j <= SIZE; j++)
			{ // если вершину j ещё не обошли, а i обошли и вес меньше min
				if ((v[i] == 0) && (v[j] == 1) && (a[i][j] < min))
				{
					// переприсваиваем
					min = a[i][j];
					w1 = 1; // новое ребро в оставное дерево
					w2 = j;
				}
			}
		v[w2] = 0;
		t[0][index] = w1;
		t[1][index] = w2;
		index++;
	} while (min < 1000);
	// Вывод рёбер оставного дерева
	cout << "Рёбра оставного дерева: \n";
	for (int i = 0; i < index; i++)
		cout << "( " << t[0][i] << "; " << t[1][i] << " )" << endl;
}
```
