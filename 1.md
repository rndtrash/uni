# Локальные и глобальные переменные

Все величины, описанные внутри функции, а также параметры функции, являются *локальными* переменными. Областью их действия является функция.
При вызове функции в стеке выделяется память под локальные автоматические переменные.

*Глобальные* переменные - это переменные, описанные вне функций. Они доступны во всех функциях, если в этих функциях нет одноимённых локальных
переменных.

__Пример.__
```cpp
int a, b; // глобальные переменные
void change()
{
	int r; // локальная переменная
	r = a;
	a = b;
	b = r;
}

void main()
{
	cin >> a, b;
	change();
	cout << "a=" << a << ";b=" << b << endl;
}
```

# Область видимости переменных

__Пример 1.__ Пример использования локальных переменных.

```cpp
int main()
{
	for (int i = 0; i < 10; i++)
	{
		int k = i * i;
		cout << k;
	}
	return 0;
}
```

__Пример 2.__ Определение глобальных переменных.

```cpp
int global_var = 0;

void my_func(void)
{
	global_var = 10;
	return;
}

int main()
{
	cout << global_var;
	my_func();
	cout << global_var;
	return 0;
}

/* Результат:
 * 0
 * 10
 */
```

__Пример 3.__ Работа с глобальными и локальными переменными.

```cpp
int var = 5;

int main()
{
	int var = 10;
	cout << var << ::var;
	return 0;
}

/* Результат:
 * 10 5
 */
```

Можно задавать класс переменных, которые объявляют внутри фигурных скобок их область видимости в этом блоке, но их значение не исчезает при
выходе из блока. Такие переменные называются статическими и задаются с помощью ключевого слова `static`.

__Пример 4.__ Использование статических переменных.

```cpp
void iter(void);

int main()
{
	for (int i = 0; i < 4; i++)
		iter();
	return 0;
}

void iter(void)
{
	int var = 1;
	static int var_st = 1;
	cout << var++ << var_st++;
}

/* Результат:
 * var = 1, var_st = 1
 * var = 1, var_st = 2
 * var = 1, var_st = 3
 * var = 1, var_st = 4
 */
```

# Параметры со значениями по умолчанию

Для некоторых параметров функции можно указывать значение по умолчанию. Эти значения будут использоваться как значение фактических параметров,
если фактические параметры не заданы явно.

__Пример.__

```cpp
int pow(const int& a, const int& p)
{
	int res = 1;
	for (int i = 1; i <= p; i++)
	{
		res = res * a;
	}
	return res;
}

cout << pow(5, 2);

// --- //

int pow(const int& a, const int& p = 2) { ... }

cout << pow(5);    // == pow(5, 2) == 25
cout << pow(5, 4); // 625
```

**Важно:** параметры с значениями по умолчаниями должны быть в конце определения функции, т.е. если один из операторов содержит значение по
умолчанию, то необходимо указать значение по умолчанию для всех последующих параметров.

# Перегрузка функций

Уникальность функции определяется не только её именем, но и списком параметров и типом возвращаемого значения. Можно создавать функцию с ранее
определённым именем, но с другим параметров. Тип таких функций может совпадать или быть различным. Однако нельзя у идентичных функций изменить
тип.

__Пример 1.__

```cpp
double frac(int a, int b)
{
	return (double) a / b;
}

double frac(double a, double b)
{
	return a / b;
}

cout << frac(7, 3) << endl; // работает первая фунция
cout << frac(7.5, 2.5) << endl; // работает вторая функция
cout << frac(3.14, 2) << endl; // ошибка: не ясно, какая из функций вызывается
```

__Пример 2.__
```cpp
double frac(int a, int b, double c = 3.14)
{
	return (double) (a / b) * c;
}
```

# Рекурсия

Функция может вызывать саму себя. Такой процесс называется *рекурсией*, причём если функция вызывает себя - это *прямая рекурсия*, а если функция
`a` вызывает функцию `b` и `b` вызывает `a`, то рекурсия называется *косвенной*.

__Пример 1.__

```cpp
int fib(int n)
{
	if (n == 1 || n == 2)
		return 1;
	else
		return fib(n - 1) + fib(n - 2);
}

int main(void)
{
	cout << fib(10);
	return 0;
}
```

Каждая рекурсивная функция должна быть хотя бы одну нерекурсивную ветвь.

__Пример 2.__ Возвести заданное число в заданную степень. Использовать рекурсивную функцию.

```cpp
#include <iostream>

using namespace std;
int power(long int x, unsigned int y);

int main()
{
	int a, b;
	cout << "Enter a number: " << endl;
	cin >> a;
	cout << "Enter a power: " << endl;
	cin >> b;
	cout << power(a, b) << endl;
	return 0;
}

int power(long int x, unsigned int y)
{
	int d = 0;
	if (y == 0)
		return 1;
	return x * power (x, y - 1);
}
```

__Пример 3.__ Найти сумму чисел от 1 до N.

```cpp
#include <iostream>

using namespace std;

int sum(int n)
{
	if (n == 1)
		return 1;
	return sum(n - 1) + n;
}

int main()
{
	cout << "1..5: " << sum(5) << endl;
}
```

__Пример 4.__ Дан массив. Найти сумму положительных элементов.

```cpp
#include <iostream>
#include <string>

int a[10];
int n;
int sum(int);

int main()
{
	int i;
	cin >> n;
	for (i = 0; i < n; i++)
		cin >> a[i];

	cout << sum(0);

	return 0;
}

int sum(int i)
{
	if (i == n)
		return 0;

	if (a[i] > 0)
		return sum(i + 1) + a[i];

	return sum(i + 1);
}
```

# Быстрая сортировка (сортировка Хоара)

В исходном массиве необходимо выбрать некоторый элемент, для которого слева располагаются элементы с ключами меньше текущего, а справа
располагаются элементы больше. Такой элемент называется *опорным*. Если такого элемента нет, то его можно получить конечным числом перестановок.
Империческим путём доказано, что лучший опорный элемент - это элемент, выбранный случайным образом.

```cpp
int a[10], b;
void hoarasort(int*, int, int);

int main()
{
	int i;
	cin >> n;
	for (i = 0; i < n; i++)
		cin >> a[i];

	hoarasort(a, 0, n - 1);
	for (i = 0; i < n; i++)
		cout << a[i];

	return 0;
}

void hoarasort(int* a, int first, int last)
{
	int i = first, j = last;
	int tmp, f = a[(first + last) / 2];
	do
	{
		while (a[i] < f) i++;
		while (a[j] > f) j--;
		if (i <= j)
		{
			if (i < j)
			{
				tmp = a[i];
				a[i] = a[j];
				a[j] = tmp;
			}
			i++;
			j++;
		}
	} while (i <= j);
	if (i < last) hoarasort(a, i, last);
	if (first < j) hoarasort(a, first, j);
}
```

