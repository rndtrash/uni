# Ссылки

Ссылка - это синоним имени объекта, указанного при инициализации ссылки. Ссылку можно рассматривать как указатель, который всегда
разыменовывается.

Синтаксис:

```cpp
тип & имя = имя_объекта;
```

Примеры:

```cpp
int x; // определение переменной
int & sx = x; // определение ссылки на переменную x
```

Правила работы со ссылками:

 1. Переменная ссылка должна явно инициализироваться при её описании.
 2. После инициализации ссылке не может быть присвоено другое значение.
 3. Не существует указателей на ссылки, массивов ссылок и ссылок на ссылки.
 4. Операция над ссылкой приводит к изменению величины, на которую она ссылается.

Ссылка не занимает дополнительного места в памяти, она является другим именем объекта.

# Динамические массивы

Если до начала работы программы количество элементов в массиве неизвестно, то следует использовать динамический массив. Память под массив
выделяется операцией `new`, адрес начала массива хранится в указателе.

Синтаксис:

```cpp
new тип_массива
int n = 10;
int * a = new int[n];
```

Пример:

```cpp
int * a = new int[100]; // выделение динамической памяти размером 100 * sizeof(int) (= 400) байтов
long(*la)[4]; // указатель на массив из 4 элементов long

la = new[2][4]; // выделение динамической памяти размером 2 * 4 * sizeof(long) байтов
int ** matr = (int **) new int[5][10]; // ещё один способ выделения памяти под двумерный массив

int ** matr;
matr = new int * [4]; // выделяем память под массив указателей int * из n элементов
for (int i = 0; i < 4; i++)
	matr[i] = new int[6]; // выделяем память под строки массива
```

Память под массив выделяется, но инициализировать элементы здесь нельзя.

Пример освобождения памяти:

```cpp
delete[] a; // освобождает память, выделенную под массив, если a адресует его начало
delete[] b;
delete[] la;

for (i = 0; i < 4; i++)
	delete[] matr[i]; // удаляем отдельные строки
delete[] matr; // удаляем массив указателей
```

__Пример 1.__ Удалить из матрицы строку с номером K

```cpp
void main()
{
	int n, m; // размерность матрицы
	int i, j;
	cin >> n >> m; // строки, затем столбцы

	// выделение памяти
	int ** matr = new int * [n]; // массив указателей на строки
	for (i = 0; i < n; i++)
		matr[i] = new int[m]; // память под элементы матрицы
	// заполнение матрицы
	for (i = 0; i < n; i++)
		for (j = 0; j < m; j++)
			matr[i][j] = rand() % 10; // заполнение матрицы
	// удаление строки с номером K
	int k;
	cout << "Enter k: ";
	cin >> k;
	int ** temp = new int * [n - 1] // формирование новой матрицы
	for (i = 0; i < n; i++)
		temp[i] = new int[m];

	// заполнение новой матрицы
	int t;
	for (i = 0, t = 0; i < n; i++)
		if (i != k)
		{
			for (j = 0; j < m; j++)
				temp[t][j] = matr[i][j];
			t++;
		}

	// удаление старой матрицы
	for (i = 0; i < n; i++)
		delete matr[i];
	delete[] matr;
	n--;

	// печать новой матрицы
}
```

__Пример 2.__ Найти сумму элементов в динамическом массиве. Размерность массива ввести с клавиатуры.
*Использовать различные варианты при обращении к массиву.*

```cpp
void main()
{
	int N;
	cout << "Введите размерность массива: ";
	cin >> N;

	// создаём массив динамически
	int * a = new int[N];

	// введём элементы массива с клавиатуры
	for (int i = 0; i < N; i++)
	{
		cout << "Введите " << i << "-й элемент массива: ";
		cin >> a[i];
	}

	int s = 0; // просуммируем элементы массива
	for (int i = 0; i < N; i++)
		s += *(a + i);

	// выведем на экран элементы массива и их сумму
	cout << "a: ";
	for (int i = 0; i < N; i++)
		cout << " " << i[a];
	cout << endl << "Сумма элементов: " << s << endl;

	// очищаем выделенную память
	delete[] a;
}
```

# Передача массивов как параметров в функцию

При передаче массива в функцию *всегда* передаётся указатель на первый элемент, то есть по умолчанию выполняется передача по адресу. Желательно
кроме массива передавать его реальный размер.

__Пример 1.__ Удалить из массива все чётные элементы

```cpp
int form(int a[100]) // заполнение массива
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> a[i];
	return n;
}

void print(int a[100], int n) // вывод массива
{
	for (int i = 0; i < n; i++)
		cout << a[i] << " ";
	cout << endl;
}

void dell(int a[100], int & n) // удаление чётных элементов
{
	int j = 0, i, b[100];
	for (i = 0; i < n; i++)
		if (a[i] % 2 != 0)
		{
			b[j] = a[i];
			j++;
		}
	n = j;
	for (i = 0; i < n; i++)
		a[i] = b[i]
}

void main()
{
	int a[100];
	int n;
	n = form(a);
	print(a, n);
	dell(a, n);
	print(a, n);
}
```

__Пример 2.__ Удалить из массива все элементы, совпадающие с первым элементом, используя динамическое выделение памяти.

```cpp
int * form(int & n)
{
	cin >> n;
	int * a = new int[n]; // указатель на динамическую область памяти
	for (int i = 0; i < n; i++)
		cin >> a[i];
	return a;
}

void print(int * a, int n)
{
	for (int i = 0; i < n; i++)
		cout << a[i] << " ";
	cout << endl;
}

int * dell(int * a, int & n)
{
	int k, j, i;
	for (k = 0, i = 0; i < n; i++)
		if (a[i] != a[0])
			k++;
	int * b = new int[k];
	for (j = 0, i = 0; i < n; i++)
		if (a[i] != a[0])
		{
			b[j] = a[i];
			j++;
		}
	n = k;
	return b;	
}

void main()
{
	int * a;
	int n;
	a = form(n);
	print(a, n);
	a = dell(a, n);
	print(a, n);
}
```

# Класс string

Подключение класса:

```cpp
#include <string>
```

Объявление переменной типа `string`:

```cpp
string s1; // переменная с именем s1 типа string
string s2 = "This is a string variable"; // объявление с инициализацией
```

Использование переменной типа `string` с оператором присваивания:

```cpp
s1 = s2; // s1 = "This is a string variable"
s2 = "New text";
```

Длину строки возвращает функция класса `size()`:

```cpp
cout << "Длина " << s2.size();
string s1; // пустая строка
```

Для проверки пустоты строки можно сравнить её длину с 0:

```cpp
if (!s1.size()) ... // true если пустая
if (s1.empty()) ... // то же самое
```

Для сравнения строк используется `==`:

```cpp
if (s1 == s2)
```

Копирование строки:

```cpp
st3 = st2; // копируем st2 в st3
```

Для конкатенации строк используется операция сложения `+` или операция сложения с присваиванием `+=`.

Пусть даны две строки: 

```cpp
string s1 = "hello, ";
string s2 = "world\n";
string s3 = s1 + s2;
```

Добавление s2 в конец s1:

```cpp
s1 += s2;
```

С объектами класса string можно использовать нижеследующие операторы

`=` - присваивание

`+` - конкатенация (объединение строк)

`+=` - присваивание с конкатенацией

`==` - равенство

`!=` - неравенство

`<` - меньше

`<=` - меньше или равно

`>` - больше

`>=` - больше или равно

`[]` - индексация

> **ВНИМАНИЕ:** `"abd" > "abcd"` - истина

Ввод строки до пробела:

```cpp
cin >> s;
```

Ввод строки целиком:

```cpp
getline(cin, s);
```
